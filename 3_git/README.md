# HUFS Missing Semester_Git, Github과 친해지기 과목 실습 읽기자료_고도희

## (참고) GitHub 저장소 생성 및 개발 환경

- 로컬 시스템에서 사용할 사용자 이름과 이메일을 설정하시고 Github저장소를 이용해주세요.

```
$ git config --global user.name "Your Name"  //본인 이름
$ git config --global user.email you@example.com //본인 이메일
```

# 녹화강의 수강내용 복습

## Git repository처음 생성하고 연결하기


```
echo "# HUFS_Missing_GithubClass" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/DohuiKo/HUFS_Missing_GithubClass.git
git push -u origin main
```

- 강의 복습 내용으로 Git repository를 생성하고 연결하는 화면을 다시 보여드립니다. 오늘 새로운 repository를 여러분들이 생성하실 것은 아닙니다. 단, 새로운 repository를 생성할 때 나오는 git 명령어들이 어떤 의미를 가지고 있는지 여러분들께서 궁금해 하실 것 같아 녹화강의 내용 복습차 여러분들께 알려드립니다.

### 설명

첫째, `git init`명령어를 사용해서 현지 위치에 지역 저장소를 만듭니다.

`git init` 명령어를 사용하시면 여러분의 로컬 저장소 즉, 여러분의 컴퓨터에 `.git 디렉터리`가 생성됩니다. `.git 디렉터리` 안에 여러분들이 작업하시는 작업물들의 **“버전”**이 기록됩니다. 아직 여러분들에게 **버전**이라는 개념이 생소하실 것이라고 생각하지만 괜찮습니다. 곧 이어서 **녹화강의 내용 보충** 챕터에서 자세히 설명 드릴 테니 지금은 이 정도만 이해하셔도 충분합니다. 

둘째, `README.md`파일을 등록합니다. 여기에 `git add` 명령어와 `git commit` 명령어도 쓰였습니다. 이 명령어들이 의미하는 바가 무엇일까요? 이를 이해하기 위해서는 Github의 **버전**이 무엇인지에 대해서 이해하셔야하기 때문에 이 또한 녹화강의 내용 보충 챕터에서 다시 설명드리겠습니다.

셋째,  `git branch -M main`은 현재 사용하는 컴퓨터의 브랜치 이름 master를 main으로 바꾼다는 뜻입니다. 이는 2020년부터 Github에서 `master`보다 `main`이라는 표현을 사용할 것을 권장하기 때문에 자동으로 포함되는 코드입니다. 따라서 여러분들이 `master` 라는 이름으로 여러분이 작업할 때 가장 기본이 되는 branch를 만드시려면 이 코드를 복사 붙여 넣기해서 사용하시면 안됩니다. 단, `master` 라는 명칭보다 `main` 이라는 명칭을 사용하도록 Github에서 권장한 이유가 인종차별적인 언어사용을 지양하기 위한 점을 감안한다면 기본 branch 이름을  `main` 으로 설정하는 것이 더 바람직할 것입니다.

넷째,`git remote` 입니다. git remote는 원격 저장소를 관리할 수 있는 명령어입니다. **원격 저장소는 인터넷이나 네트워크**, 즉 Github 웹페이지에서 볼 수 있는 저장소인 것 알고 계시죠? 그래서 여기 보이는 명령어를 통해서 여러분의 원격 저장소 이름을 지어주고 생성하면서 Github repository 링크와 연결하는 것입니다. 참고로 별다른 설정이 없다면 원격 저장소의 default name은 `origin` 이니 참고해두시기 바랍니다.

- `git remote add <원격 저장소 이름> 본인 깃허브 repo링크` (기본 명령어: 참고)

 *원격 저장소 이름은 일반적으로 origin을 사용하지만 다른 이름으로 바꿀 수도 있습니다.

[! 기본 origin으로 만들어진 원격저장소 이름을 바꾸고 싶어요 !](http://minsone.github.io/git/github-managing-remotes-renaming-a-remote)

정리하자면 맨 처음 나오는 이 코드를 복사 붙여넣기함을 통해서 origin으로 원격 저장소 이름이, main이 현재 사용하는 컴퓨터의 브랜치 이름으로 설정되는 것입니다. `README.md` 파일도 생성되고요.

*이 과정에서 만약에 아래와 같은 에러가 발생한다면?

```
//에러메세지 : ‘원격에 로컬에 없는 작업이 포함되어 업데이트가 거부되었습니다’
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

- force push를 통해서 해결할 수 있습니다.

`git push -f origin main`

*참고로 원격 저장소를 지울 수도 있습니다.

- `git remove` : 원격 저장소 지우기

# 녹화강의 내용 보충


## 우리가 생각하는 일반적인 ‘버전’

여러분들은 여기 보이는 사진처럼 완성 결과물이 바뀔 때 마다 `다른이름으로 저장` 하여 파일을 저장한 경험이 있을 겁니다. 따라서 버전이라는 개념을 이미 접해본 경험이 있다고 볼 수 있습니다. 일반적으로 문서를 작성할 때 변경사항이 있으면 수정을 하고, 수정하기 전 원본파일을 보존하고 싶다면 다른이름으로 저장을 하고, 수정 전/수정 후 여러 개의 파일이 지속적으로 만들어지게 됩니다. 파일 이름 네이밍을 통해서 어느 시간대, 어떤 특성을 가진 결과물이 수정한 파일의 특이사항을 유추할 수 있게끔 도와주기는 하지만 이렇게 만들어진 버전은 숫자가 많아지면 관리가 어렵다는 단점이 있습니다. 그래서 요즘은 Github을 개발자가 아닌 마케터나 디자이너도 활용할만큼 활용도가 높습니다.

이렇게 우리가 word나 한글 파일을 작성할 때는 여러 파일이 생성해야만 여러 버전으로 저장이 가능하지만, 문서관리 툴인 Git을 사용한다면 다른 이름으로 여러 파일을 생성할 필요도 없으며 각각 다른 이름을 가진 파일마다 어떤 변경사항이 적용된 것인지까지도 `commit message` 를 통해서 함께 관리할 수 있게되는 것입니다.

정리하자면 `Git` 을 사용한다면 문서를 수정하고 저장할 때마다 ‘버전’이 생기고, ‘버전’만 관리한다면 ‘최종본’, ‘최최종본’처럼 새로 이름을 부여하지 않고 원래 파일 이름을 그대로 유지하면서 파일에서 무엇을 변경했는지 변경 시점마다 저장할 수 있습니다. 무엇보다도 각 버전을 `Git`에서 모두 저장하고 있기 때문에 현재 버전에 문제가 있다면 이전 버전으로 쉽게 돌아갈 수 있다는 것이 가장 큰 장점이다.

## Git의 버전

그렇다면 이제 본격적으로 Git의 버전에 대해서 알아볼까요?



### 스테이지와 커밋

- Git은 어떻게 파일 이름은 그대로 유지하면서 수정 내역을 기록할까요? 그 이유는 바로 Git에 스테이지와 저장소라는 가상의 공간이 존재하기 때문입니다. 이제 각각이 무엇인지 설명드리겠습니다.

### 작업트리

- 작업트리(working tree)는 파일 수정, 저장 등의 작업을 하는 디렉터리(폴더)로, ‘작업 디렉터리(working directory)’라고도 합니다. 즉, 여러분이 작업을 하는 곳, 우리 눈에 보이는 디렉터리가 바로 작업트리입니다.

### 스테이지

- 스테이지(stage)는 버전으로 만들 파일이 대기하는 곳입니다. 이곳을 스테이징 영역(staging area)라고 부르기도 하는데요. 예를 들어 작업 트리에서 10개의 파일을 수정했는데 4개의 파일만 버전으로 만들고 싶다면 4개의 파일만 스테이지로 넘겨주면 됩니다.

### 로컬 저장소

- 저장소(repository)는 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 곳입니다.

Git은 원격 저장소와 로컬 저장소 두 종류의 저장소를 제공합니다.

- 원격 저장소(Remote Repository)는 파일이 원격 저장소 전용 서버에서 관리되며 여러 사람이 함께 공유하기 위한 저장소입니다.
- 로컬 저장소(Local Repository)는 내 PC에 파일이 저장되는 개인 전용 저장소입니다.

이때, 맨 처음 소개드린 명령어 `git init` 을 한 파일 안에 `.git 디렉터리` 가 생성되어 관리되고 있다는 점을 알아두셔야 합니다. 평소에는 숨긴 항목으로 지정돼있어서 눈에 보이지 않습니다. 그래서 스테이지와 저장소는 눈에 보이지 않는 개념이기 때문에 많은 사람들이 깃을 접하는데 어려움을 겪는다고 생각합니다. //(슬라이드 넘김) 이럴 때는  `.git 디렉토리` 안에 숨은 파일 형태로 존재한다는 것을 기억하시면 이해하는데 도움이될 것입니다.

이제 작업트리와 스테이지, 저장소가 각각 무엇인지 알았으니 맨처음 간단하게 언급하고 넘어갔던 `git add` `git commit` `git push` 명령어와 Git의 버전이 어떤 관계인지 알아봅시다.

### Git이 버전을 만드는 과정은 어떠한가

- 예를 들어, 여러분이 `[README.md](http://README.md)` 파일에 “저는 고도희입니다”라는 문구를 추가하고 저장했다고 가정합시다. 이 상태가 바로 ‘작업트리’에서 작업이 완료된 상태인 것입니다. Git을 모르던 시절에는 문서만 저장하면 되었지만 이제는 Git을 사용할 수 있게 되었으니 `README.md`  파일을 수정하며 수정한 시점에서 버전으로 만들어 관리하고 싶을 때 스테이지에 넣으면 됩니다.
- 파일 수정을 끝내고 `git add` 명령어를 입력하시면 해당 파일을 스테이지에 넣을 수 있습니다. 이렇게 스테이지에 파일을 add한 다음에 `git commit` 명령어를 통해 새로운 버전을 생성할 수 있습니다. 커밋 명령을 내리면 새로운 버전이 생성되면서 스테이지에 대기하던 파일이 모두 로컬 저장소에 저장됩니다.
- 마지막으로 `$ git push` 명령어를 사용하시면 드디어 여러분의 로컬 저장소에 등록된 파일이 모두 원격 저장소에도 등록되어 인터넷 상에서 여러분의 코드를 확인할 수 있게 됩니다.

### 버전을 직접 만들어보자

1. 작업트리에서 문서 수정합니다.
2. 수정한 파일 중 버전으로 만들고 싶은 것을 `git add` 하여 스테이지에 저장합니다.(스테이징한다)

3, 스테이지에 있던 파일을  `git commit`  명령어를 입력하여 로컬 저장소로 스테이징해줍니다. 이렇게 되면 새로운 버전이 생성된 것입니다.  `git log`커멘트를 통해서 새로운 버전이 생성되었는지 확인할 수 있습니다. 


- 변경사항을 한꺼번에 확인하는데에는 `git log --oneline` 명령어가 용이합니다.
    
    
- 참고로 가장 쉬운 방법은 github 사이트에서 확인하는 것입니다.
    
    원격 저장소 연결되어 있는 url로 이동 → commits 클릭 → 확인
    

- 참고로 현재 로컬 저장소에 변화는 없는지, commit은 잘 반영되었는지 알아보기 위해서는 `git status` 명령어를 사용하시면 됩니다.

## Github 필수 명령어 소개

### 1) 깃 저장소 만들기

- 깃 초기화하기 - `$ git init`
- 현재 디렉터리안에 어떤 문서 있는지 확인 `$ ls`
- 디렉터리간 이동 `$ cd [이동할 디렉터리 이름 ]`
- 상위 폴더로 이동 `$ cd ..`

### 2) 버전 만들기

- 현재 깃의 상태 확인하기 `$ git status`
- 수정한 파일을 스테이징 하기 `$ git add [스테이징할 파일 이름]`

*한꺼번에 모든 변경사항을 올리려면 `$ git add .`

- 스테이지에 올라온 파일 커밋하기 `$ git commit -m “message"`

### 3) 커밋 내용 확인하기

- 버전이 제대로 만들어졌는지 확인하기 `$ git log`

*간략하게 한 줄로 표기하려면 `$ git log —oneline`

- 변경 사항 확인하기 `$ git diff`

이때 명령어들의 쓰임새를 살펴봅시다. 여기 이미지를 보시면 쉽게 이해하실 수 있는데요. `commit` 옆에 기다란 영문 표기가 되어있는 문장을 `커밋 해시` 라고 합니다. `커밋 해시` 는 버전의 이름이라고 생각하시면 됩니다. 그래서 이 개념을 응용하면 `$ git reset --hard [커밋 해시]` 명령어를 사용하여 특정 버전으로 이동할 수 있게 되는 것입니다. 한 가지 더 말씀드리자면, 현재 작업하기 직전의 버전으로 이동할 때는 커밋 해시 필요 없이 `$ git reset --hard HEAD^` 명령어를 사용하시면 됩니다. 왜 `HEAD^` 을 사용하면 이전 명령어로 돌아가질 까요? 그것은  `HEAD` 가 가장 최신의 버전을 뜻하고, `^` 문자가 “이전”을 의미하기 때문이죠. 응용한다면 `HEAD~2` 이런식으로 이전의 이전 버전으로 이동하는 것도 가능합니다. 이 외에는 커밋에 대한 정보가 `git log` 에 담겨지게 되는데요, Git이 협업을 위한 도구인 만큼 누가 작성한 commit인지, 버전을 만든 날짜는 언제인지, commit을 하면서 남긴 메세지는 무엇인지 확인할 수 있습니다.

참고로, `commit` 할 때 작성하는 `message` 는 나중에 협업할 때 해당 버전에서 어떤 작업을 마친 것인지 확인할 수 있는 근거가 되기 때문에 [깃 커밋 메세지 컨벤션](https://determination.tistory.com/entry/%EA%B9%83-%EC%BB%A4%EB%B0%8B-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%BB%A8%EB%B2%A4%EC%85%98Git-Commit-Message-Convention)을 더 자세히 공부해보시는 것을 추천드립니다.


또, `$ git diff` 명령어를 활용하면 변경사항이 무엇이 있는지 구체적으로 확인할 수 있습니다.


### 4) 작업 되돌리기

- 최신 커밋 되돌리기 `$ git reset --hard HEAD^`

# 안전하게 깃허브로 협업하기

## 깃과 브랜치

### 1) 브랜치란?

- 만약 여러분들의 프로젝트에서 서비스 개선을 해야할 부분이 있어 신 기능이나 급하게 변경해야 하는데 바로 통합 프로젝트에 적용했을 때 문제가 발생할 수도 있지 않을까요? 이럴 때 독립적으로 작업을 해서 확인을 하는 용도로 작업하는 공간을 신설하여 변경 작업을 하는 것을 브랜치라고 합니다.

### 2) 새 브랜치 만들기

- 깃에서 브랜치가 무엇이 있는지 확인하는 명령어 `$git branch`
- 새 브랜치 생성하는 명령어 `$git branch [새로 생성할 브랜치 이름]`
- git branch명령어를 입력하면 현재 자신이 작업하고 있는 위치의 branch에 * 표시가 됨.
- 브랜치 사이를 이동하려면? `$ git checkout [이동할 브랜치 이름]`

### 3) 브랜치 머지하기

- 머지하려면 먼저 main브랜치로 이동하자. `$ git checkout main`
- 병합 명령어 `$ git merge [병합하고 싶은 브랜치 이름]`
- 머지 후 만들었던 브랜치를 삭제하고 싶다면? `$ git branch -d [삭제하려는 브랜치 이름]`

## Fork란? (실습 과제)

- branch를 생성하여 작업을 해야할 필요성에 대해서 이미 언급해드려서 잘 알고 있을 것이라고 생각합니다. 저는 그것에서 더 나아가 오픈소스에 기여하면서, 원본 원격 저장소의 branch를 파서 작업하는 것 보다도 더 안전하게 협업하는 방법에 대해서 알려드리려고 합니다. 그것은 바로 `Fork` 라는 개념을 활용하는 것인데요. Fork란, 다른 사람의 원격 저장소를 통째로 복사하는 것 입니다.

- 이에 대해서는 이미 실시간 강의 시간에 설명드렸습니다.


**Fork하여 협업하는 방법 설명**

- 여러분들이 조별과제를 하는데, 팀장이 깃허브 원격 저장소를 관리하는 주체라고 가정을 해봅시다. 여기까지 배웠다면 팀장의 원격 저장소에 팀원인 여러분들이 branch를 만들어서 사용할텐데, 혹시 Github을 사용하는 방법을 잘 모르는 팀원이 main branch에서 잘못 작업을 하게될 수도 있잖아요? 이런 상황에 대비해서 한 층 더 안전하게 깃허브 원격 저장소를 수정하면서 협업하기 위해서는 팀장의 원격 저장소(git repository)를 복제하여 내 원격 저장소로 가져온 다음에 수정사항이 있다면 수정을 한 후 팀장에게 보내는 방법이 있습니다.

사실 Github에 대해서 팀원들이 모두 잘 알더라도 Fork를 선호해서 작업하는 경우도 있습니다. **왜  Fork라는 방식을 사용할까요?**

- fork는 다른 사람의 github repository를 복제하여 어떤 부분을 수정, 추가, 삭제를 용이하도록 해주는 복제기능입니다. fork한 저장소는 원본 저장소와 연결되어 있어서 원본에 변화가 생기면 그대로 fork해온 저장소에 반영할 수 있습니다. 이때, fetch나 rebase의 과정을 거치게 되며, 원본 저장소에 변경사항을 적용시키고 싶다면 해당 저장소에 pull request를 해야합니다. 즉, pull request 하기 전까지는 내 guthub에 fork해온 저장소에만 변화가 적용되는 것이죠. fork해온 저장소에서 작업을 하다가 무언가가 잘못되면, 잘못 되어도 원본 저장소의 버전으로 다시 돌아가 작업을 할 수 있다는 이점이 있습니다.

### 실습 과제 process 요약

이제 직접 `Fork` 라는 개념에 대해서 실습 할 차례입니다. Github 의 동작 원리에 대해서 더 잘 이해하기 위해서 fork와 branch 개념을 함께 실습하도록 내용을 구성했습니다. 실습 내용을 요약하자면 **[다른 사람의 원격 저장소를 자신의 원격 저장소에 fork한 다음 (여러분의) 로컬 저장소로 clone한 다음 branch를 만들고 커밋 푸쉬를 한 다음 main에 merge하고, 다른사람의 원격저장소에 pull request를 보내는 방법]** 이었습니다. 제공해드린 PDF 파일에 자세한 내용이 첨부되어 있었던 것을 기억하시겠지요?

[실습 내용 복습]

- 다른 사람이 만든 저장소를 Fork하기
- Fork한 레포 clone해서 내 저장소로 가져오기
- 수정 후 fork한 저장소에서 branch생성
- branch 생성 후 “2022 동계 훕스 미씽시매스터 + 본인 이름” 저장 후 branch에 스테이징 및 푸쉬
- main브랜치로 돌아와서 branch 변경사항 merge하기
- merge를 통해서 수정사항 main에 반영 완료 후 PR(Pull Request)
